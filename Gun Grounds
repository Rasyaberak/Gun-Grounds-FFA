local distance = Value3
local height = Value2
local speed = Value1
-- made By Projeto LKB scriptblox.com --

loadstring(game:HttpGet(("https://raw.githubusercontent.com/REDzHUB/LibraryV2/main/redzLib")))()
local l = loadstring(game:HttpGet("https://raw.githubusercontent.com/laagginq/ui-libraries/main/dxhooknotify/src.lua", true))()

MakeWindow({
  Hub = {
    Title =  "[FPS] Gun Grounds FFA",
    Animation = "By RasyX"
  },
  Key = {
    KeySystem = false,
    Title = "Key System",
    Description = "[FPS] Gun Grounds FFA",
    KeyLink = "https://raw.githubusercontent.com/dqtixz/key-system-mdfgbgk-dwflgk-nerrnmtr/main/ryj11374973493528790352797537297%20246949%2054795ergjternbrt%20j",
    Keys = {"keyjgfeihefnm22","Projeto"},
    Notifi = {
      Notifications = true,
      CorrectKey = "Running the Script...",
      Incorrectkey = "The key is incorrect",
      CopyKeyLink = "Copied to Clipboard"
    }
  }
})

-- Initialize the loading tab and label
local CheckLoading = MakeTab({Name = "Loading Status"})
local LabelLoading = AddTextLabel(CheckLoading, "Initializing...")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Function to update the label with a loading sequence
local function UpdateLabel(text, duration)
    LabelLoading.Text = text
    wait(duration)
end

-- Function to verify user and player information
local function VerifyUser()
    if LocalPlayer and LocalPlayer.UserId then
        if LocalPlayer.Name and LocalPlayer.Name ~= "" then
            return true
        end
    end
    return false
end

-- Loading sequence
local function LoadingSequence()
    local messages = {
        "Verifying User... üîé",
        "Verifying Player Info... üë§",
        "Initializing Script... ‚è≥"
    }

    for i, message in ipairs(messages) do
        UpdateLabel(message, 1)
        if i < #messages then
            UpdateLabel(message .. " | Progress: " .. i .. "/" .. #messages, 0.5)
        end
    end

    if VerifyUser() then
        UpdateLabel("User Verified Successfully!", 1)
        UpdateLabel("Welcome, " .. LocalPlayer.Name .. "!", 1)
    else
        UpdateLabel("User Verification Failed!", 2)
        return
    end

    UpdateLabel("All systems go! üöÄ", 1)
end

LoadingSequence()
wait(1)

-- Logs Tab
local MainLogs = MakeTab({Name = "Logs"})
AddParagraph(MainLogs, {"Made By RasyX"})
AddParagraph(MainLogs, {"[ FEATURES ] AimBot ( NEW ),"})
AddParagraph(MainLogs, {"21/09/2024", "Version 0.0.1"})
wait(1)
AddParagraph(MainLogs, {"There will probably be a script update, coming soon!! üëΩ"})
wait(1)

local Main = MakeTab({Name = "Aim"})
wait(1)
local Paragraph = AddParagraph(Main, {"Script Only WallCheck No Team Check !", "Aim (Head, Torso) Small, Medium, Big - Esp Player Speed, Inf Jump"})
wait(1)

-- Aimbot Configuration
local config = {
    Fov = 180,                            -- Field of view for aiming
    MaxTransparency = 0.1,                -- Transparency level
    Smoothness = 0.1,                     -- Smoother aim transition (higher = slower)
    TargetPart = "Head",                  -- Part to aim at (e.g., "Head", "Torso")
    TeamCheck = false,                    -- Only aim at enemies, not teammates
    WallCheck = true,                     -- Avoid shooting through walls
    MaxDistanceEnabled = false,           -- Use distance limit for targets
    MaxDistance = 1500,                   -- Max distance for aiming
    FovColor = Color3.fromRGB(102, 45, 145), -- Color of the FOV circle
    RecoilX = 2,                          -- Recoil control for X-axis (left-right)
    RecoilY = 5,                          -- Recoil control for Y-axis (up-down)
    FireRate = 0.2,                       -- Time delay between shots (in seconds)
    AimAssistStrength = 0.5,              -- Aim assist strength (0.0 to 1.0)
    FakeLagEnabled = true,                -- Enable fake lag
    FakeLagAmount = 0.1                   -- Fake lag delay (in seconds)
}

-- Variables for recoil control
local recoilX, recoilY = config.RecoilX, config.RecoilY
local currentRecoilX, currentRecoilY = 0, 0

-- Variables for fire rate limiter
local lastShotTime = os.clock()

-- Variables for fake lag
local fakeLagEnabled = config.FakeLagEnabled
local fakeLagAmount = config.FakeLagAmount

-- Function to control recoil
local function applyRecoilControl()
    currentRecoilX = currentRecoilX - recoilX * 0.1
    currentRecoilY = currentRecoilY - recoilY * 0.1
    moveMouse(currentRecoilX, currentRecoilY)
end

-- Function to check fire rate
local function canShoot()
    local currentTime = os.clock()
    if (currentTime - lastShotTime) >= config.FireRate then
        lastShotTime = currentTime
        return true
    else
        return false
    end
end

-- Function to apply aim assist
local function applyAimAssist(targetX, targetY)
    local screenCenterX, screenCenterY = getScreenCenter()
    local dx, dy = targetX - screenCenterX, targetY - screenCenterY
    moveMouse(screenCenterX + dx * config.AimAssistStrength, screenCenterY + dy * config.AimAssistStrength)
end

-- Function for fake lag
local function applyFakeLag()
    if fakeLagEnabled then
        wait(fakeLagAmount)
    end
end

-- Function to display target info
local function displayTargetInfo(target)
    if target and target.Character and target.Character:FindFirstChild(config.TargetPart) then
        local humanoid = target.Character:FindFirstChild("Humanoid")
        local distance = (target.Character.Head.Position - game.Players.LocalPlayer.Character.Head.Position).magnitude
        print("Target Info: Health = " .. humanoid.Health .. ", Distance = " .. math.floor(distance) .. " studs")
    end
end

-- Main aim and shoot function
local function aimAndShoot()
    local player = game.Players.LocalPlayer
    local camera = game.Workspace.CurrentCamera
    local targetPlayer = nil

    while true do
        targetPlayer = nil
        local closestDistance = math.huge

        -- Loop through all players to find the closest valid target
        for _, playerInstance in pairs(game.Players:GetPlayers()) do
            if playerInstance ~= player and playerInstance.Character and playerInstance.Character:FindFirstChild(config.TargetPart) then
                local targetPos = playerInstance.Character[config.TargetPart].Position
                local screenPos = camera:WorldToScreenPoint(targetPos)

                -- Check if the target is within the FOV and distance
                local fovRadius = config.Fov / 2
                local distance = (targetPos - player.Character.Head.Position).magnitude
                if (Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2) - Vector2.new(screenPos.X, screenPos.Y)).magnitude < fovRadius and distance < closestDistance then
                    closestDistance = distance
                    targetPlayer = playerInstance
                end
            end
        end

        if targetPlayer then
            local targetHead = targetPlayer.Character[config.TargetPart].Position
            local aimPos = targetHead

            -- Smooth aim adjustment
            camera.CFrame = CFrame.new(camera.CFrame.Position, aimPos)

            -- Recoil control
            applyRecoilControl()

            -- Fire rate check
            if canShoot() then
                -- Aim assist
                local screenX, screenY = camera:WorldToScreenPoint(targetHead)
                applyAimAssist(screenX, screenY)

                -- Shoot at the target
                shootAtTarget(targetPlayer)

                -- Fake lag
                applyFakeLag()

                -- Display target info
                displayTargetInfo(targetPlayer)
            end
        end

        wait(0.01) -- Short delay for optimization
    end
end

-- Utility functions for your environment
function getScreenCenter()
    return game.Workspace.CurrentCamera.ViewportSize.X / 2, game.Workspace.CurrentCamera.ViewportSize.Y / 2
end

function moveMouse(x, y)
    -- Simulate moving the mouse in your game environment (this is just an example)
    mousemoveabs(x, y)
end

function shootAtTarget(target)
    local humanoid = target.Character:FindFirstChild("Humanoid")
    if humanoid and humanoid.Health > 0 then
        humanoid:TakeDamage(10)  -- Simulate dealing damage (customize as needed)
    end
end

-- Start the aimbot when the button is clicked
AddButton(Main, {
    Name = "AimBot",
    Callback = function()
        aimAndShoot() -- Begin the aim and shoot loop
    end
})

local Main = MakeTab({Name = "Esp Player"})
wait(0.1)

AddButton(Main, {
  Name = "Esp Rocket",
  Callback = function()

-- Made By dqtixz --
local Settings = {
    Box_Color = Color3.fromRGB(255, 0, 0),
    Box_Thickness = 2,
    Team_Check = false,
    Team_Color = false,
    Autothickness = true,
    HealthBar = true, -- Health Bar ESP
    HeadDot = true -- Head Dot ESP
}

--Locals
local Space = game:GetService("Workspace")
local Player = game:GetService("Players").LocalPlayer
local Camera = Space.CurrentCamera

-- Locals
local function NewLine(color, thickness)
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = color
    line.Thickness = thickness
    line.Transparency = 1
    return line
end

local function NewCircle(color, radius) -- Updated Head Dot Function
    local circle = Drawing.new("Circle")
    circle.Visible = false
    circle.Color = color
    circle.Thickness = 1
    circle.NumSides = 30
    circle.Radius = radius
    circle.Filled = true
    circle.Transparency = 0.5 -- Make it transparent
    return circle
end

local function NewBar(color) -- Health Bar Function
    local bar = Drawing.new("Line")
    bar.Visible = false
    bar.Color = color
    bar.Thickness = 2
    return bar
end

local function Vis(lib, state)
    for i, v in pairs(lib) do
        v.Visible = state
    end
end

local function Colorize(lib, color)
    for i, v in pairs(lib) do
        v.Color = color
    end
end

local function Rainbow(lib, delay)
    for hue = 0, 1, 1/30 do
        local color = Color3.fromHSV(hue, 0.6, 1)
        Colorize(lib, color)
        wait(delay)
    end
    Rainbow(lib)
end

--Main Draw Function
local function Main(plr)
    repeat wait() until plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil

    local Library = {
        TL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness)
    }

    if Settings.HealthBar then
        Library.HealthBar = NewBar(Color3.fromRGB(0, 255, 0))
    end

    if Settings.HeadDot then
        Library.HeadDot = NewCircle(Color3.fromRGB(255, 255, 255), 3) -- Smaller head dot to match Roblox head size
    end

    coroutine.wrap(Rainbow)(Library, 0.15)

    local oripart = Instance.new("Part")
    oripart.Parent = Space
    oripart.Transparency = 1
    oripart.CanCollide = false
    oripart.Size = Vector3.new(1, 1, 1)
    oripart.Position = Vector3.new(0, 0, 0)

    --Updater Loop
    local function Updater()
        local c 
        c = game:GetService("RunService").RenderStepped:Connect(function()
            if plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 then
                local Hum = plr.Character
                local HumPos, vis = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position)

                if vis then
                    oripart.Size = Vector3.new(Hum.HumanoidRootPart.Size.X, Hum.HumanoidRootPart.Size.Y * 1.5, Hum.HumanoidRootPart.Size.Z)
                    oripart.CFrame = CFrame.new(Hum.HumanoidRootPart.CFrame.Position, Camera.CFrame.Position)

                    local SizeX = oripart.Size.X
                    local SizeY = oripart.Size.Y
                    local TL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(SizeX, SizeY, 0)).p)
                    local TR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-SizeX, SizeY, 0)).p)
                    local BL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(SizeX, -SizeY, 0)).p)
                    local BR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-SizeX, -SizeY, 0)).p)

                    if Settings.Team_Check then
                        if plr.TeamColor == Player.TeamColor then
                            Colorize(Library, Color3.fromRGB(0, 255, 0))
                        else 
                            Colorize(Library, Color3.fromRGB(255, 0, 0))
                        end
                    end

                    if Settings.Team_Color then
                        Colorize(Library, plr.TeamColor.Color)
                    end

                    -- Health Bar
                    if Settings.HealthBar then
                        local healthRatio = Hum.Humanoid.Health / Hum.Humanoid.MaxHealth
                        local BarStart = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position - Vector3.new(2, 3, 0))
                        local BarEnd = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position - Vector3.new(2, 3 + 5 * healthRatio, 0))
                        Library.HealthBar.From = Vector2.new(BarStart.X, BarStart.Y)
                        Library.HealthBar.To = Vector2.new(BarEnd.X, BarEnd.Y)
                        Library.HealthBar.Visible = true
                    end

                    -- Head Dot
                    if Settings.HeadDot and Hum:FindFirstChild("Head") then
                        local headPos = Camera:WorldToViewportPoint(Hum.Head.Position)
                        Library.HeadDot.Position = Vector2.new(headPos.X, headPos.Y)
                        Library.HeadDot.Radius = math.clamp(7 / headPos.Z, 3, 6) -- Adjust dot size based on distance
                        Library.HeadDot.Visible = true
                    end

                    -- Auto thickness and visibility
                    local ratio = (Camera.CFrame.p - Hum.HumanoidRootPart.Position).magnitude
                    local offset = math.clamp(1/ratio * 750, 2, 300)

                    Library.TL1.From = Vector2.new(TL.X, TL.Y)
                    Library.TL1.To = Vector2.new(TL.X + offset, TL.Y)
                    Library.TL2.From = Vector2.new(TL.X, TL.Y)
                    Library.TL2.To = Vector2.new(TL.X, TL.Y + offset)

                    Library.TR1.From = Vector2.new(TR.X, TR.Y)
                    Library.TR1.To = Vector2.new(TR.X - offset, TR.Y)
                    Library.TR2.From = Vector2.new(TR.X, TR.Y)
                    Library.TR2.To = Vector2.new(TR.X, TR.Y + offset)

                    Library.BL1.From = Vector2.new(BL.X, BL.Y)
                    Library.BL1.To = Vector2.new(BL.X + offset, BL.Y)
                    Library.BL2.From = Vector2.new(BL.X, BL.Y)
                    Library.BL2.To = Vector2.new(BL.X, BL.Y - offset)

                    Library.BR1.From = Vector2.new(BR.X, BR.Y)
                    Library.BR1.To = Vector2.new(BR.X - offset, BR.Y)
                    Library.BR2.From = Vector2.new(BR.X, BR.Y)
                    Library.BR2.To = Vector2.new(BR.X, BR.Y - offset)

                    Vis(Library, true)

                    if Settings.Autothickness then
                        local distance = (Player.Character.HumanoidRootPart.Position - oripart.Position).magnitude
                        local value = math.clamp(1/distance * 100, 1, 4)
                        for u, x in pairs(Library) do
                            x.Thickness = value
                        end
                    else 
                        for u, x in pairs(Library) do
                            x.Thickness = Settings.Box_Thickness
                        end
                    end
                else 
                    Vis(Library, false)
                end
            else 
                Vis(Library, false)
                if game:GetService("Players"):FindFirstChild(plr.Name) == nil then
                    for i, v in pairs(Library) do
                        v:Remove()
                        oripart:Destroy()
                    end
                    c:Disconnect()
                end
            end
        end)
    end

    coroutine.wrap(Updater)()
end

for i, v in pairs(game:GetService("Players"):GetPlayers()) do
    if v ~= Player then
        coroutine.wrap(Main)(v)
    end
end

game:GetService("Players").PlayerAdded:Connect(function(v)
    coroutine.wrap(Main)(v)
end)
wait(0.1)
l:Notify("Visual Script Load","Esp (Rocket)",3)
end
})

AddButton(Main, {
  Name = "Esp Arrow",
  Callback = function()
    local DistFromCenter = 80
local TriangleHeight = 16
local TriangleWidth = 16
local TriangleFilled = true
local TriangleTransparency = 0
local TriangleThickness = 1
local TriangleColor = Color3.fromRGB(255, 255, 255)
local AntiAliasing = false

----------------------------------------------------------------

local Players = game:service("Players")
local Player = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local RS = game:service("RunService")

local V3 = Vector3.new
local V2 = Vector2.new
local CF = CFrame.new
local COS = math.cos
local SIN = math.sin
local RAD = math.rad
local DRAWING = Drawing.new
local CWRAP = coroutine.wrap
local ROUND = math.round

local function GetRelative(pos, char)
    if not char then return V2(0,0) end

    local rootP = char.PrimaryPart.Position
    local camP = Camera.CFrame.Position
    local relative = CF(V3(rootP.X, camP.Y, rootP.Z), camP):PointToObjectSpace(pos)

    return V2(relative.X, relative.Z)
end

local function RelativeToCenter(v)
    return Camera.ViewportSize/2 - v
end

local function RotateVect(v, a)
    a = RAD(a)
    local x = v.x * COS(a) - v.y * SIN(a)
    local y = v.x * SIN(a) + v.y * COS(a)

    return V2(x, y)
end

local function DrawTriangle(color)
    local l = DRAWING("Triangle")
    l.Visible = false
    l.Color = color
    l.Filled = TriangleFilled
    l.Thickness = TriangleThickness
    l.Transparency = 1-TriangleTransparency
    return l
end

local function AntiA(v)
    if (not AntiAliasing) then return v end
    return V2(ROUND(v.x), ROUND(v.y))
end

local function ShowArrow(PLAYER)
    local Arrow = DrawTriangle(TriangleColor)

    local function Update()
        local c ; c = RS.RenderStepped:Connect(function()
            if PLAYER and PLAYER.Character then
                local CHAR = PLAYER.Character
                local HUM = CHAR:FindFirstChildOfClass("Humanoid")

                if HUM and CHAR.PrimaryPart ~= nil and HUM.Health > 0 then
                    local _,vis = Camera:WorldToViewportPoint(CHAR.PrimaryPart.Position)
                    if vis == false then
                        local rel = GetRelative(CHAR.PrimaryPart.Position, Player.Character)
                        local direction = rel.unit

                        local base  = direction * DistFromCenter
                        local sideLength = TriangleWidth/2
                        local baseL = base + RotateVect(direction, 90) * sideLength
                        local baseR = base + RotateVect(direction, -90) * sideLength

                        local tip = direction * (DistFromCenter + TriangleHeight)
                        
                        Arrow.PointA = AntiA(RelativeToCenter(baseL))
                        Arrow.PointB = AntiA(RelativeToCenter(baseR))

                        Arrow.PointC = AntiA(RelativeToCenter(tip))

                        Arrow.Visible = true

                    else Arrow.Visible = false end
                else Arrow.Visible = false end
            else 
                Arrow.Visible = false

                if not PLAYER or not PLAYER.Parent then
                    Arrow:Remove()
                    c:Disconnect()
                end
            end
        end)
    end

    CWRAP(Update)()
end

for _,v in pairs(Players:GetChildren()) do
    if v.Name ~= Player.Name then
        ShowArrow(v)
    end
end

Players.PlayerAdded:Connect(function(v)
    if v.Name ~= Player.Name then
        ShowArrow(v)
    end
end)
wait(0.1)
l:Notify("Visual Script Load","Esp (Arrow)",3)
    end
})

AddButton(Main, {
  Name = "Esp Line",
  Callback = function()
local Settings = {
    Color = Color3.fromRGB(65, 105, 225), -- Color of the line
    Thickness = 1, -- Thickness of the line (Overruled by AutoThickness if activated)
    Transparency = 0.3, -- 1 Visible - 0 Not Visible
    AutoThickness = true, -- Makes Thickness above futile, scales according to distance, good for less encumbered screen
    Length = 15, -- In studs of the line
    Smoothness = 0.2 -- 0.01 - Less Smooth(Faster), 1 - Smoother (Slower)
}

local toggle = true -- use this variable if you wanna integrate into a GUI

local player = game:GetService("Players").LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera

local function ESP(plr) --//Main function handling specific plr loop esp for line etc
    local line = Drawing.new("Line") --// Parse and Set the line for tracer
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = Settings.Color
    line.Thickness = Settings.Thickness
    line.Transparency = Settings.Transparency

    local function Updater() --// Function to update the ESP therefore, line destinations etc every /render/
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function() -- Putting function in a connection var in order to disconnect if needed, to save performance
            if toggle and plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("Head") ~= nil then
                local headpos, OnScreen = camera:WorldToViewportPoint(plr.Character.Head.Position)
                if OnScreen then -- checks if player is on screen or not
                    local offsetCFrame = CFrame.new(0, 0, -Settings.Length)
                    local check = false
                    line.From = Vector2.new(headpos.X, headpos.Y)
                    if Settings.AutoThickness then
                        local distance = (player.Character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).magnitude --//AutoThickness
                        local value = math.clamp(1/distance*100, 0.1, 3) --0.1 is min thickness, 4 is max
                        line.Thickness = value
                    end
                    repeat
                        local dir = plr.Character.Head.CFrame:ToWorldSpace(offsetCFrame)
                        offsetCFrame = offsetCFrame * CFrame.new(0, 0, Settings.Smoothness)
                        local dirpos, vis = camera:WorldToViewportPoint(Vector3.new(dir.X, dir.Y, dir.Z))
                        if vis then
                            check = true
                            line.To = Vector2.new(dirpos.X, dirpos.Y)
                            line.Visible = true
                            offsetCFrame = CFrame.new(0, 0, -Settings.Length)
                        end
                    until check == true
                else 
                    line.Visible = false
                end
            else 
                line.Visible = false
                if game.Players:FindFirstChild(plr.Name) == nil then
                    connection:Disconnect()
                end
            end
        end)
    end
    coroutine.wrap(Updater)()
end

for i, v in pairs(game:GetService("Players"):GetPlayers()) do
    if v.Name ~= player.Name then
        coroutine.wrap(ESP)(v)
    end
end

game.Players.PlayerAdded:Connect(function(newplr)
    if newplr.Name ~= player.Name then
        coroutine.wrap(ESP)(newplr)
    end
end)
wait(0.1)
l:Notify("Visual Script Load","Esp (Line)",3)
end
})

AddButton(Main, {
    Name = "Esp Highlight",
    Callback = function()
        local FillColor = Color3.fromRGB(150, 255, 150) -- Even brighter green for close range
        local DepthMode = "AlwaysOnTop"
        local FillTransparency = 0.5
        local OutlineColor = Color3.fromRGB(255, 255, 255)
        local OutlineTransparency = 0

        local CoreGui = game:FindService("CoreGui")
        local Players = game:FindService("Players")
        local lp = Players.LocalPlayer
        local connections = {}

        local Storage = Instance.new("Folder")
        Storage.Parent = CoreGui
        Storage.Name = "Highlight_Storage"

        local function UpdateHighlightColor(Highlight, distance)
            if distance < 20 then
                Highlight.FillColor = Color3.fromRGB(150, 255, 150) -- Brighter green for close
            elseif distance < 50 then
                Highlight.FillColor = Color3.fromRGB(255, 220, 0) -- Brighter orange for medium range
            else
                Highlight.FillColor = Color3.fromRGB(255, 100, 100) -- Brighter red for far away
            end
        end

        local function Highlight(plr)
            local Highlight = Instance.new("Highlight")
            Highlight.Name = plr.Name
            Highlight.FillColor = FillColor
            Highlight.DepthMode = DepthMode
            Highlight.FillTransparency = FillTransparency
            Highlight.OutlineColor = OutlineColor
            Highlight.OutlineTransparency = OutlineTransparency
            Highlight.Parent = Storage

            local function UpdateAdornee(char)
                if char then
                    Highlight.Adornee = char
                end
            end

            -- Set the initial Adornee to the player's character
            UpdateAdornee(plr.Character)

            -- Update Adornee when the player's character respawns
            connections[plr] = plr.CharacterAdded:Connect(function(char)
                UpdateAdornee(char)
            end)

            -- Constantly update the color based on distance
            local distanceConnection
            distanceConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if plr and plr.Character and lp and lp.Character then
                    local distance = (lp.Character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).Magnitude
                    UpdateHighlightColor(Highlight, distance)
                end
            end)

            -- Store connection so it can be cleaned up later
            connections[plr] = {characterConnection = connections[plr], distanceConnection = distanceConnection}
        end

        Players.PlayerAdded:Connect(Highlight)

        for i, v in next, Players:GetPlayers() do
            Highlight(v)
        end

        Players.PlayerRemoving:Connect(function(plr)
            if Storage:FindFirstChild(plr.Name) then
                Storage[plr.Name]:Destroy()
            end
            if connections[plr] then
                -- Disconnect both CharacterAdded and distance updates
                connections[plr].characterConnection:Disconnect()
                connections[plr].distanceConnection:Disconnect()
                connections[plr] = nil
            end
        end)
    end
})

AddButton(Main, {
    Name = "Esp Name & Position",
    Callback = function()
        local CoreGui = game:FindService("CoreGui")
        local Players = game:FindService("Players")
        local lp = Players.LocalPlayer
        local connections = {}
        
        -- Create a storage folder for the BillboardGuis
        local Storage = Instance.new("Folder")
        Storage.Parent = CoreGui
        Storage.Name = "NamePosition_Storage"

        -- Function to update position display and dynamic scaling
        local function UpdatePlayerGui(plr, billboardGui, distance)
            if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = plr.Character.HumanoidRootPart
                billboardGui.Adornee = hrp

                -- Update text with player name and position
                local position = hrp.Position
                billboardGui.TextLabel.Text = plr.Name .. "\n(" .. math.floor(position.X) .. ", " .. math.floor(position.Y) .. ", " .. math.floor(position.Z) .. ")"
                
                -- Scale the text size based on distance (farther = smaller)
                local scale = math.clamp(1 / distance, 0.1, 1)
                billboardGui.TextLabel.TextSize = 16 * scale
            end
        end

        -- Create the BillboardGui for each player
        local function CreateBillboardGui(plr)
            if not plr.Character then return end

            local billboardGui = Instance.new("BillboardGui")
            billboardGui.Name = plr.Name .. "_Gui"
            billboardGui.Size = UDim2.new(0, 200, 0, 50) -- Default size
            billboardGui.StudsOffset = Vector3.new(0, 3, 0) -- Offset to appear above the player
            billboardGui.AlwaysOnTop = true

            -- Create the TextLabel for displaying name and position
            local textLabel = Instance.new("TextLabel")
            textLabel.Size = UDim2.new(1, 0, 1, 0)
            textLabel.BackgroundTransparency = 1
            textLabel.TextColor3 = Color3.new(1, 1, 1) -- White text
            textLabel.TextScaled = true
            textLabel.Parent = billboardGui
            billboardGui.Parent = Storage

            -- Constantly update the position display
            local distanceConnection
            distanceConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if plr and plr.Character and lp and lp.Character then
                    local distance = (lp.Character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).Magnitude
                    UpdatePlayerGui(plr, billboardGui, distance)
                end
            end)

            connections[plr] = {distanceConnection = distanceConnection}
        end

        -- Add BillboardGui when a player is added
        Players.PlayerAdded:Connect(function(plr)
            CreateBillboardGui(plr)

            -- Handle player respawn
            plr.CharacterAdded:Connect(function()
                if Storage:FindFirstChild(plr.Name .. "_Gui") then
                    Storage[plr.Name .. "_Gui"]:Destroy()
                end
                CreateBillboardGui(plr)
            end)
        end)

        -- For existing players when the script is run
        for i, v in next, Players:GetPlayers() do
            CreateBillboardGui(v)
        end

        -- Cleanup when players leave
        Players.PlayerRemoving:Connect(function(plr)
            if Storage:FindFirstChild(plr.Name .. "_Gui") then
                Storage[plr.Name .. "_Gui"]:Destroy()
            end
            if connections[plr] then
                connections[plr].distanceConnection:Disconnect()
                connections[plr] = nil
            end
        end)
    end
})

local Main = MakeTab({Name = "Extras"})
wait(0.1)

local Paragraph = AddParagraph(Main, {"Script Extras", "Spin Player for when it teleports to all players"})
wait(0.1)

AddButton(Main, {
  Name = "Rejoin Server",
  Callback = function()
    l:Notify("Alert !","Rejoin Server...",3)
    wait(0.1)
local ts = game:GetService("TeleportService")
local p = game:GetService("Players").LocalPlayer
ts:Teleport(game.PlaceId, p)
end
})

local Toggle = AddToggle(Main, {
  Name = "Spin Player",
  Default = false,
  Callback = function(Value)
Toggled = Value

local players = game:GetService("Players")
local player = game.Players.LocalPlayer

while Toggled do
    for _, otherPlayer in pairs(players:GetPlayers()) do
        if otherPlayer ~= player then
            local distance = 10
            local height = 10
            local speed = 10
            local start = player.Character.HumanoidRootPart.Position
            local target = otherPlayer.Character.HumanoidRootPart.Position + Vector3.new(0, height, 0)
            local direction = (target - start).unit
            
            for t = 0, 1, 0.05 do
                player.Character:SetPrimaryPartCFrame(CFrame.new(start + direction * distance * t))
                wait(1/30)
            end
            
            for i = 0, 360, 15 do
                local rotation = CFrame.Angles(0, math.rad(i), 0)
                local offset = rotation * Vector3.new(0, height, distance)
                
                player.Character:SetPrimaryPartCFrame(CFrame.new(target + offset))

                wait(1/30) -- 1/30
            end
        end
    end
    wait(5)
end
 end
})

local Toggle = AddToggle(Main, {
  Name = "Inf Jump",
  Default = false,
  Callback = function(Value)
Toggled = Value
    
local InfiniteJumpEnabled = Value

game:GetService("UserInputService").JumpRequest:connect(function()

	if InfiniteJumpEnabled then		game:GetService"Players".LocalPlayer.Character:FindFirstChildOfClass'Humanoid':ChangeState("Jumping")

	end

end)
 end
})

AddTextBox(Main, {
  Name = "Walk Air",
  Default = "",
  PlaceholderText = "Value",
  ClearText = true,
  Callback = function(Value)
    game:GetService("Workspace")[game.Players.LocalPlayer.Name]:FindFirstChildOfClass(
'Humanoid').HipHeight = Value
 end
})
wait(1)
AddButton(Main, {
  Name = "Spin (Not Recommend)",
  Callback = function()
power = 1000 -- change this to make it more or less powerful
 
game:GetService('RunService').Stepped:connect(function()
game.Players.LocalPlayer.Character.Head.CanCollide = false
game.Players.LocalPlayer.Character.Torso.CanCollide = false
game.Players.LocalPlayer.Character["Left Leg"].CanCollide = false
game.Players.LocalPlayer.Character["Right Leg"].CanCollide = false
end)
 
wait(.1)
local bambam = Instance.new("BodyThrust")
bambam.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
bambam.Force = Vector3.new(power,0,power)
bambam.Location = game.Players.LocalPlayer.Character.HumanoidRootPart.Position
    
  end
})

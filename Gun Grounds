local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local MainWindow = Rayfield:CreateWindow({
   Name = "[FPS] Gun Grounds FFA",
   LoadingTitle = "Loading ...",
   LoadingSubtitle = "Made By R4syX",
   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "R4syX Hub"
   },
   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "R4syX Hub",
      Subtitle = "Key System",
      Note = "Key: confidential",
      FileName = "R4syKey", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"confidential"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local MainTab = MainWindow:CreateTab("Main", 4483362458) -- Title, Image

local aimBotEnabled = false  -- Global variable to track the AimBot state
local aimBotLoop = nil       -- Store the aimBot loop for easy control

-- Create the AimBot toggle
local Toggle1 = MainTab:CreateToggle({
    Name = "AimBot",
    CurrentValue = false,
    Flag = "Toggle_AimBot", -- Unique flag for AimBot
    Callback = function(Value)
        aimBotEnabled = Value -- Set AimBot state based on toggle

        if aimBotEnabled then
            print("AimBot Enabled")
            -- Start the AimBot loop when enabled
            aimBotLoop = coroutine.create(function()
                aimAndShoot(config)  -- Start aim and shoot loop
            end)
            coroutine.resume(aimBotLoop)
        else
            print("AimBot Disabled")
            -- Stop the AimBot loop by killing the coroutine
            if aimBotLoop then
                coroutine.yield(aimBotLoop)  -- Pause the coroutine to stop aim loop
            end
        end
    end,
})

-- Configuration for AimBot
local config = {
    Fov = 180,
    MaxTransparency = 0.1,
    Smoothness = 0.1, -- Increase for smoother animation
    TargetPart = "Head",
    TeamCheck = false,
    WallCheck = true,
    MaxDistanceEnabled = false,
    MaxDistance = 1500,
    FovColor = Color3.fromRGB(102, 45, 145)
}

-- Load external AimBot script
loadstring(game:HttpGet("https://raw.githubusercontent.com/dqtixz/aimbot/main/Projeto%20LKA%20x%20F%20Hub", true))()
wait(0.1)

-- Function to handle aiming with animation and auto-shoot (Mobile Compatible)
local function aimAndShoot(config)
    _G.config = config

    local player = game.Players.LocalPlayer
    local camera = game.Workspace.CurrentCamera
    local targetPlayer = nil

    -- Smooth aim function with animation
    local function smoothAim(targetPos, currentPos)
        local smoothSpeed = config.Smoothness
        return currentPos:Lerp(targetPos, smoothSpeed)
    end

    -- Auto-shoot function (for mobile)
    local function autoShoot(target)
        if target then
            -- Simulate a tap to shoot
            local humanoid = target.Parent:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                humanoid:TakeDamage(10)  -- Example of dealing damage directly
            end
        end
    end

    -- Highlight target function for visual feedback
    local function highlightTarget(target)
        if target and target.Character and target.Character:FindFirstChild(config.TargetPart) then
            local head = target.Character[config.TargetPart]
            head.BrickColor = BrickColor.new("Bright red") -- Change color to indicate hit
            wait(0.1)
            head.BrickColor = BrickColor.new("White") -- Revert color after a short delay
        end
    end

    -- Main aim loop
    while aimBotEnabled do  -- Only run when AimBot is enabled
        -- Find closest player to aim at (can add TeamCheck and WallCheck conditions)
        targetPlayer = nil
        local closestDistance = math.huge

        for _, playerInstance in pairs(game.Players:GetPlayers()) do
            if playerInstance ~= player and playerInstance.Character and playerInstance.Character:FindFirstChild(config.TargetPart) then
                local targetPos = playerInstance.Character[config.TargetPart].Position
                local screenPos = camera:WorldToScreenPoint(targetPos)

                -- Check if target is within the FOV
                local fovRadius = config.Fov / 2
                local distance = (targetPos - player.Character.Head.Position).magnitude
                if (Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2) - Vector2.new(screenPos.X, screenPos.Y)).magnitude < fovRadius and distance < closestDistance then
                    closestDistance = distance
                    targetPlayer = playerInstance
                end
            end
        end

        if targetPlayer then
            -- Smooth aim towards the target
            local aimPos = smoothAim(targetPlayer.Character[config.TargetPart].Position, camera.CFrame.Position)
            camera.CFrame = CFrame.new(camera.CFrame.Position, aimPos)
            
            -- Silent aim: Temporarily set camera position to aim
            local oldPos = camera.CFrame
            camera.CFrame = CFrame.new(camera.CFrame.Position, aimPos)
            autoShoot(targetPlayer.Character[config.TargetPart]) -- Auto-shoot when aiming at target
            highlightTarget(targetPlayer) -- Highlight target when hit
            camera.CFrame = oldPos -- Restore camera position
        end

        wait(0.01) -- Add a short delay for optimization
    end
end

local Toggle2 = MainTab:CreateToggle({
    Name = "ESP",
    CurrentValue = false,
    Flag = "Toggle_ESP", -- Unique flag for ESP
    Callback = function(Value)
        if Value then
            print("ESP Enabled")
            -- Enable ESP for existing players
            for _, v in pairs(game:GetService("Players"):GetPlayers()) do
                if v.Name ~= Player.Name then
                    coroutine.wrap(Main)(v)
                end
            end
            
            -- Connect to new players joining
            game:GetService("Players").PlayerAdded:Connect(function(newplr)
                coroutine.wrap(Main)(newplr)
            end)
        else
            print("ESP Disabled")
            -- Disable and clean up ESP for all players
            for _, v in pairs(game:GetService("Players"):GetPlayers()) do
                if v.Name ~= Player.Name then
                    Vis(Library, false) -- Assuming Library holds the drawing lines
                    -- Here, you may want to add more cleanup if needed
                end
            end
            -- Disconnect the PlayerAdded event
            if PlayerAddedConnection then
                PlayerAddedConnection:Disconnect()
            end
        end
    end,
})

-- Settings and Local Variables
local Settings = {
    Box_Color = Color3.fromRGB(255, 0, 0),
    Box_Thickness = 2,
    Team_Check = false,
    Team_Color = false,
    Autothickness = true,
    Pulse_Distance = 50, -- Set pulse effect distance
    Pulse_Color = Color3.fromRGB(0, 255, 0),
    Visibility_Check = true
}

-- Locals
local Space = game:GetService("Workspace")
local Player = game:GetService("Players").LocalPlayer
local Camera = Space.CurrentCamera
local RunService = game:GetService("RunService")

-- Locals
local function NewLine(color, thickness)
    local line = Drawing.new("Line")
    line.Visible = false
    line.From = Vector2.new(0, 0)
    line.To = Vector2.new(0, 0)
    line.Color = color
    line.Thickness = thickness
    line.Transparency = 1
    return line
end

local function Vis(lib, state)
    for _, v in pairs(lib) do
        v.Visible = state
    end
end

local function Colorize(lib, color)
    for _, v in pairs(lib) do
        v.Color = color
    end
end

local Black = Color3.fromRGB(0, 0, 0)

local function Rainbow(lib, delay)
    for hue = 0, 1, 1 / 30 do
        local color = Color3.fromHSV(hue, 0.6, 1)
        Colorize(lib, color)
        wait(delay)
    end
    Rainbow(lib)
end

-- Main Draw Function
local function Main(plr)
    repeat wait() until plr.Character and plr.Character:FindFirstChild("Humanoid")

    local R15 = plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R15
    local Library = {
        TL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        TR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        BR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
        HeadBox = NewLine(Color3.fromRGB(255, 255, 255), Settings.Box_Thickness) -- Head Position Indicator
    }

    coroutine.wrap(Rainbow)(Library, 0.15)

    -- Pulse Effect Timer
    local function PulseEffect(lib)
        while true do
            for _, v in pairs(lib) do
                v.Color = Settings.Pulse_Color
                wait(0.05)
                v.Color = Settings.Box_Color
                wait(0.05)
            end
        end
    end

    local oripart = Instance.new("Part")
    oripart.Parent = Space
    oripart.Transparency = 1
    oripart.CanCollide = false
    oripart.Size = Vector3.new(1, 1, 1)
    oripart.Position = Vector3.new(0, 0, 0)

    -- Updater Loop
    local function Updater()
        local c 
        c = RunService.RenderStepped:Connect(function()
            if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character:FindFirstChild("Head") then
                local Hum = plr.Character
                local HumPos, vis = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position)

                -- Visibility Check
                if Settings.Visibility_Check then
                    local hitResult = Camera:ViewportPointToRay(HumPos.X, HumPos.Y).Direction
                    if hitResult ~= Hum.HumanoidRootPart.Position then
                        vis = false -- Block if behind objects
                    end
                end

                if vis then
                    -- Head Position Indicator
                    local HeadPos = Camera:WorldToViewportPoint(Hum.Head.Position)
                    Library.HeadBox.From = Vector2.new(HeadPos.X - 5, HeadPos.Y - 5)
                    Library.HeadBox.To = Vector2.new(HeadPos.X + 5, HeadPos.Y + 5)
                    Library.HeadBox.Visible = true

                    oripart.Size = Vector3.new(Hum.HumanoidRootPart.Size.X, Hum.HumanoidRootPart.Size.Y * 1.5, Hum.HumanoidRootPart.Size.Z)
                    oripart.CFrame = CFrame.new(Hum.HumanoidRootPart.CFrame.Position, Camera.CFrame.Position)

                    -- Box Drawing
                    local TL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(oripart.Size.X, oripart.Size.Y, 0)).p)
                    local TR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-oripart.Size.X, oripart.Size.Y, 0)).p)
                    local BL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(oripart.Size.X, -oripart.Size.Y, 0)).p)
                    local BR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-oripart.Size.X, -oripart.Size.Y, 0)).p)

                    Library.TL1.From = Vector2.new(TL.X, TL.Y)
                    Library.TL1.To = Vector2.new(TL.X + 10, TL.Y)
                    Library.TL2.From = Vector2.new(TL.X, TL.Y)
                    Library.TL2.To = Vector2.new(TL.X, TL.Y + 10)

                    -- Weapon Display
                    if plr.Character:FindFirstChildOfClass("Tool") then
                        local weapon = plr.Character:FindFirstChildOfClass("Tool").Name
                        print("Player holding: " .. weapon)
                    end

                    -- Pulse Effect: Active if player is close
                    local distance = (Player.Character.HumanoidRootPart.Position - oripart.Position).magnitude
                    if distance <= Settings.Pulse_Distance then
                        coroutine.wrap(PulseEffect)(Library)
                    end

                    Vis(Library, true)
                else 
                    Vis(Library, false)
                end
            else
                Vis(Library, false)
                if game:GetService("Players"):FindFirstChild(plr.Name) == nil then
                    for _, v in pairs(Library) do
                        v:Remove()
                        oripart:Destroy()
                    end
                    c:Disconnect()
                end
            end
        end)
    end

    coroutine.wrap(Updater)()
end

-- Draw Boxes
for _, v in pairs(game:GetService("Players"):GetPlayers()) do
    if v.Name ~= Player.Name then
        coroutine.wrap(Main)(v)
    end
end

game:GetService("Players").PlayerAdded:Connect(function(newplr)
    coroutine.wrap(Main)(newplr)
end)
